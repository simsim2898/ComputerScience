- 기존 단일 처리기 시스템에서 CPU 스케줄링 문제를 다루었으나, 다중 처리기 환경에서는 여러 개의 CPU를 병렬로 사용할 수 있어 **부하 공유(load sharing)** 가 가능함.
- 하지만 CPU 스케줄링 문제는 더욱 복잡해지며, 단일 처리기에서 사용했던 방법들로는 최적의 해결이 어려움.
- 최신 컴퓨터 시스템에서는 **다중 처리기 아키텍처**가 일반적이며, 다음과 같은 시스템에서 활용됨:
    - 다중 코어 CPU
    - 다중 스레드 코어
    - NUMA 시스템
    - 이기종 다중 처리

## 5.5.1 다중 처리기 스케줄링 접근 방법
### 1. 비대칭 다중 처리 (Asymmetric Multiprocessing, AMP)
- 마스터 서버 모델을 사용하여 하나의 CPU가 스케줄링을 전담하고 나머지 CPU들은 사용자 프로세스를 실행.
- 장점: 데이터 공유가 필요 없어 구조가 단순.
- 단점: 마스터 CPU의 과부하 가능성이 높음.
![[5.5.1.1.png]]
### 2. 대칭 다중 처리 (Symmetric Multiprocessing, SMP)
- 각 프로세서가 개별적으로 스케줄링을 수행하는 방식.
- 스케줄링 대상이 되는 스레드를 관리하는 두 가지 전략:
    1. 모든 스레드가 **공동 준비 큐**(Common Ready Queue)에 있음.
    2. 각 프로세서가 **개별 준비 큐**(Per-Core Run Queues)를 가짐.
- SMP 시스템에서는 개별 프로세서가 스케줄링을 수행하여 부하 분배를 효율적으로 관리.

## 5.5.2 다중 코어 프로세서
- **SMP 시스템**에서는 여러 개의 물리적 처리기를 통해 다중 프로세스를 병렬 실행 가능.
- 현대 컴퓨터 하드웨어는 **하나의 칩 내부에 여러 개의 코어를 포함**하는 **다중 코어 프로세서**(multicore processor) 구조를 채택.
- 각 코어는 독립적인 구조를 가지지만, 운영체제에서는 **논리적 CPU**로 인식됨.

### 2. 다중 코어 스케줄링 문제

- 다중 코어 환경에서는 CPU 스케줄링이 더욱 복잡해짐.
- 주요 문제점
    1. **메모리 스톨(memory stall)** : 프로세서가 메모리에 접근할 때 데이터가 사용 가능할 때까지 대기해야 하는 현상.
        - 최신 프로세서는 메모리보다 훨씬 빠르므로 자주 발생.
        - 캐시 미스(cache miss)로 인해 스톨이 발생할 수도 있음.
![[5.5.2.1.png]]
    2. **칩 다중 스레딩(Chip Multithreading, CMT)** : 하나의 코어에서 **2개 이상의 하드웨어 스레드를 실행**하여 성능 최적화.
        - 하드웨어 지원을 통해 실행 가능한 스레드를 효율적으로 관리.
![[5.5.2.2.png]]
    3. **하이퍼-스레딩(Simultaneous Multithreading, SMT)**
        - 하나의 하드웨어 코어에서 **여러 개의 논리적 스레드**를 실행.
        - **Intel 프로세서**는 하이퍼-스레딩을 활용하여 논리적 CPU를 증가시킴.
        - 예: 4개의 물리적 코어가 있을 때, 각 코어에서 2개의 하드웨어 스레드를 실행 → 운영체제에서는 8개의 논리적 CPU로 인식.
![[5.5.2.3.png]]
    4. **이중 스레드 처리 코어의 2단계 스케줄링**
        - 운영체제는 논리적 CPU에서 실행될 소프트웨어 스레드를 먼저 선택.
        - 이후 하드웨어가 실행할 특정 스레드를 결정.
        - 예: UltraSPARC T3는 채택된 접근법을 사용하여 하드웨어 스케줄링을 최적화.
![[5.5.2.4.png]]
## 5.5.3 부하 균등화
- SMP 시스템에서는 부하를 모든 프로세서에 고르게 분배하는 것이 중요함.
- 부하 균등화 방법
    1. Push Migration : 특정 프로세서가 부하가 많아지면 다른 프로세서로 강제 이동.
    2. Pull Migration : 가벼운 부하의 프로세서가 대기 중인 프로세스를 가져옴.
- 일부 시스템에서는 두 가지 방법을 혼합하여 사용.

## 5.5.4 처리기 선호도
- 프로세스가 실행되던 처리기에 계속 할당되는 것이 성능에 유리함.
- 유형
    1. 약한 선호도 (Soft Affinity): 운영체제가 가능하면 동일한 CPU에서 실행되도록 하지만, 필요하면 이동 가능.
    2. 강한 선호도 (Hard Affinity): 특정 프로세서에서만 실행되도록 제한.
- NUMA 시스템에서는 특정 CPU가 메모리 접근 시간을 최적화하기 위해 선호도를 고려해야 함.
![[5.5.4.1.png]]
## 5.5.5 이기종 다중 처리
- 일부 시스템에서는 서로 다른 성능을 가진 CPU 코어를 조합하여 활용.
- 대표적인 예: big.LITTLE 아키텍처
    - **Big 코어** : 높은 성능이 필요할 때 사용.
    - **Little 코어** : 에너지를 절약해야 할 때 사용.
- 예시:
    - CPU 스케줄러는 **빅 코어**에서 고성능 작업을 실행하고, **리틀 코어**에서 백그라운드 작업을 실행하여 전력 소비를 최적화.