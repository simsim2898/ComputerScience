CPU 스케줄링은 준비 큐(Ready Queue)에 있는 프로세스 중 어떤 프로세스에 CPU를 할당할지를 결정하는 과정이다. 다양한 알고리즘이 있으며, 이를 비교하여 적절한 방법을 선택할 수 있다.

## 5.3.1 선입 선처리 스케줄링(FCFS)
- 가장 간단한 CPU 스케줄링 알고리즘.
- CPU를 먼저 요청한 프로세스부터 실행하는 방식.
- FIFO(First-In, First-Out) 방식으로 큐를 관리한다.

핵심 : 간단하지만 Convoy Effect(호위 효과) 발생.
### 예제 
프로세스 도착 순서가 `P1 -> P2 -> P3`이고, CPU 버스트 시간이 다음과 같을 경우:
![[5.3.1.1.png]]
Gantt 차트로 표현하면
![[5.3.1.2.png]]
- P1의 대기 시간: `0ms`
- P2의 대기 시간: `24ms`
- P3의 대기 시간: `27ms`
- 평균 대기 시간: `(0 + 24 + 27) / 3 = 17ms`
- 문제점
	- Convoy Effect (호위 효과) : 짧은 프로세스가 긴 프로세스를 기다려야 하는 문제 발생.
	- 선입 선처리(FCFS)는 비선점(Nonpreemptive) 스케줄링 알고리즘이므로 CPU를 점유한 프로세스가 실행을 마칠 때까지 기다려야 한다.

## 5.3.2 최단 작업 우선 스케줄링(SJF)
- 다음 실행할 CPU 버스트 시간이 가장 짧은 프로세스를 선택하는 방식.
- 두 개의 프로세스가 같은 CPU 버스트 시간을 가지면 FCFS 방식으로 처리한다.

핵심 : 평균 대기 시간 최소화, 하지만 Starvation 문제 발생 가능.
### 예제 
프로세스의 CPU 버스트 시간이 다음과 같을 경우
![[5.3.2.1.png]]
SJF 알고리즘을 적용한 Gantt 차트
![[5.3.2.2.png]]
- 평균 대기 시간 계산
	- P1: `3ms`
	- P2: `16ms`
	- P3: `9ms`
	- P4: `0ms`
	- 평균 대기 시간: `(3 + 16 + 9 + 0) / 4 = 7ms`
- 특징
	- 평균 대기 시간을 최소화할 수 있음.
	- 비선점(SJF Nonpreemptive) 및 선점(Preemptive SJF 또는 SRTF - Shortest Remaining Time First) 방식이 존재.
- 문제점
	- CPU 버스트 시간을 미리 알아야 함 (예측 문제).
	- 긴 프로세스가 계속 대기하는 Starvation(기아) 문제 발생 가능.

## 5.3.3 라운드 로빈 스케줄링(RR)
- 선입 선처리(FCFS) 방식과 유사하지만, 프로세스마다 할당된 시간(Time Quantum)이 있음.
- 시간 할당량(`time quantum`) 동안만 실행 후, 다음 프로세스로 교체.
- 준비 큐는 순환 큐(Circular Queue) 구조로 동작.

핵심 : 선점형 방식으로 응답 시간이 빠르지만, 문맥 교환 오버헤드 문제가 존재.
### 예제
프로세스의 CPU 버스트 시간과 스케줄링 방식
![[5.3.3.1.png]]
시간 할당량(`Time Quantum`)을 `4ms`로 설정하면
![[5.3.3.2.png]]

- 평균 대기 시간
	- P1: `6ms`
	- P2: `4ms`
	- P3: `7ms`
	- 평균 대기 시간: `(6 + 4 + 7) / 3 = 5.66ms`
- 특징
	- 응답 시간을 단축할 수 있음.
	- 시간 할당량 크기에 따라 성능이 크게 좌우됨.
	    - 너무 크면 FCFS와 유사하게 동작.
	    - 너무 작으면 문맥 교환(Context Switch) 오버헤드 증가.
- 문제점
	- 시간 할당량이 너무 작으면 문맥 교환 오버헤드가 많아져 성능이 저하됨.
	- 시간 할당량이 너무 크면 FCFS와 유사하게 동작하여 짧은 프로세스의 대기 시간이 길어짐.
	- 적절한 Time Quantum을 설정하는 것이 중요하며, 일반적으로 CPU 버스트 시간의 80% 이하로 설정해야 효율적이다.



