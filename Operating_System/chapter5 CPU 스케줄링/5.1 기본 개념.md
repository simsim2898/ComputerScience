코어가 하나인 시스템에서는 한 순간에 하나의 프로세스만 실행될 수 있다. 나머지 프로세스들은 CPU가 사용 가능해질 때까지 대기해야 한다. 다중 프로그래밍의 목표는 CPU 이용률을 극대화하는 것이다. 

항상 실행 중인 프로세스를 유지하는 것이 핵심

하나의 프로세스는 일반적으로 I/O 요청을 기다리는 동안 CPU를 사용하지 않는다. 이 때문에 단순한 시스템에서는 CPU가 유휴 상태가 되는 경우가 많다. 다중 프로그래밍 기법을 활용하면 CPU 사용률을 극대화할 수 있으며, 여러 프로세스가 번갈아가며 실행될 수 있도록 운영체제가 CPU를 효율적으로 할당해야 한다.
## 5.1.1 CPU-I/O 버스트 사이클
CPU 스케줄링의 성공은 프로세스들의 다양성과 특성에 따라 결정된다. 프로세스 실행은 CPU 실행(CPU burst)과 I/O 대기(I/O burst)의 반복으로 구성된다.
- 프로세스는 CPU 버스트로 실행을 시작한 후, 이후 I/O 요청이 발생하면 I/O 버스트 상태로 전환된다.
- 이후 다시 CPU 버스트가 발생하고, 이러한 과정이 반복되다가 최종적으로 실행이 종료된다.
- CPU 바운드 프로세스는 긴 CPU 버스트를 가지는 반면, I/O 바운드 프로세스는 짧은 CPU 버스트와 잦은 I/O 요청을 특징으로 한다.
- CPU 스케줄링의 알고리즘을 설계할 때 프로세스의 특성을 고려하는 것이 중요하다.
## 5.1.2 CPU 스케줄러
CPU가 유휴 상태가 될 때마다 운영체제는 실행 준비가 완료된 프로세스 중 하나를 선택하여 CPU를 할당한다. 
이 역할을 담당하는 것이 CPU 스케줄러이다.
- CPU 스케줄러는 실행 대기 중인 프로세스를 메모리에서 선택하여 CPU를 할당하는 작업을 수행한다.
- 준비 큐는 반드시 FIFO(First In, First Out) 방식이 아닐 수도 있으며, 우선순위 큐, 트리 구조, 연결 리스트 등 다양한 형태로 구현될 수 있다.
- 모든 대기 프로세스는 CPU를 기다리며 스케줄링되기 때문에 효율적인 CPU 할당 전략이 필요하다.
## 5.1.3 선점 및 비선점 스케줄링
CPU 스케줄링은 다음과 같은 네 가지 주요 상황에서 발생할 수 있다.
1. 실행 중인 프로세스가 I/O 요청으로 인해 대기 상태로 전환될 때 (예: `wait()` 호출).
2. 실행 중인 프로세스가 준비 완료 상태로 전환될 때 (예: 인터럽트 발생).
3. 대기 상태의 프로세스가 준비 완료 상태로 변경될 때 (예: I/O 작업 완료 후 CPU 실행 가능).
4. 프로세스가 완전히 종료될 때.

이 중 1번과 4번의 경우 CPU 스케줄링 선택의 여지가 없지만, 2번과 3번의 경우 선택이 가능하다.  
이를 기준으로 스케줄링 방식은 다음 두 가지로 나뉜다.
- 비선점 스케줄링(Nonpreemptive Scheduling) : 한 프로세스가 CPU를 점유한 상태에서 종료되거나 대기 상태로 전환될 때까지 CPU를 유지한다.
- 선점 스케줄링(Preemptive Scheduling) : 프로세스가 실행 중이라도 더 높은 우선순위의 프로세스가 등장하면 CPU를 빼앗아 실행할 수 있다.

최신 운영체제(WIndows, macOS, Linux 등)에서는 대부분 선점 스케줄링을 사용한다.

## 5.1.4 디스패치

CPU 스케줄링의 핵심 요소 중 하나는 디스패처(Dispatcher) 이다.  
디스패처는 CPU 스케줄러가 선택한 프로세스를 실제로 실행시키는 역할을 담당한다.

디스패처의 주요 기능
- 한 프로세스에서 다른 프로세스로 문맥 전환.
- 사용자 모드(User Mode)로 전환.
- 프로그램 실행을 다시 시작하기 위해 적절한 메모리 위치로 이동.

디스패처는 최대한 빠르게 실행되어야 하며, 이때 소요되는 시간이 디스패치 지연(dispatch latency) 이라고 한다.  
디스패치 지연이 크면 CPU 활용도가 낮아질 수 있으므로 운영체제에서는 이를 최소화하는 것이 중요하다

- 자발적 문맥 교환(voluntary context switch) : 프로세스가 I/O 작업을 기다리는 경우 발생.
- 비자발적 문맥 교환(nonvoluntary context switch) : 더 높은 우선순위 프로세스가 등장하여 **CPU를 선점(preemption)한 경우 발생.