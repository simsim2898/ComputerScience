다중 프로그래밍 의 목적은 CPU 이용률을 극대화하여 항상 어떤 프로세스가 실행되도록 하는 것이다. 이를 위해 운영체제는 프로세스 스케줄링을 수행하여, CPU 코어에서 실행할 프로세스를 선택하고 교체한다.

- 단일 CPU 코어 시스템에서는 한 번에 오직 하나의 프로세스만 실행 가능하다.
- 다중 코어 시스템에서는 여러 프로세스를 동시에 실행할 수 있다.

CPU보다 많은 프로세스가 존재하면, 사용 가능한 코어가 부족한 프로세스는 다시 스케줄될 때까지 대기해야 한다. 현재 메모리에 존재하는 프로세스의 개수를 다중 프로그래밍 정도라고 한다.
또한, 프로세스는 CPU와 I/O 사용 패턴에 따라 I/O 바운드 프로세스와 CPU 바운드 프로세스로 나뉜다.

- I/O 바운드 프로세스는 계산보다 I/O 요청을 자주 수행하는 프로세스이다.
- CPU 바운드 프로세스는 계산 시간이 길며, I/O 요청을 거의 하지 않는다.

운영체제는 이러한 특성을 고려하여 프로세스 스케줄링을 최적화한다.

## 3.2.1 스케줄링 큐
프로세스가 시스템에 들어오면 준비 큐에 저장되며, CPU 코어에서 실행되기를 기다린다. 이 준비 큐는 연결 리스트 형태로 저장되며, 각 PCB(프로세스 제어 블록)는 다음 PCB를 가리키는 포인터를 포함한다.

시스템에는 여러 종류의 큐가 존재하며, 프로세스 상태에 따라 이동한다.
- 준비 큐(Ready Queue)
    - CPU 할당을 기다리는 프로세스가 저장된다.
    - 프로세스는 디스패치(dispatch) 되어 실행 상태로 전환된다.
- 대기 큐(Wait Queue)
    - I/O 요청이나 자식 프로세스 종료 대기 등의 이유로 실행을 멈춘 프로세스가 저장된다.
    - I/O 요청이 완료되거나 대기 이벤트가 끝나면 다시 준비 큐로 이동한다.
![[3.2.1.1.png]]

 프로세스의 흐름
1. 새 프로세스는 준비 큐에 들어간다.
2. CPU를 할당받아 실행되면, 여러 이벤트 중 하나가 발생한다.
    - I/O 요청 발생 → I/O 대기 큐로 이동
    - 자식 프로세스 생성 → 자식 종료 대기 큐로 이동
    - 타임 슬라이스 만료 또는 인터럽트 발생 → 다시 준비 큐로 이동
3. 프로세스가 종료되면, 모든 큐에서 제거되고 PCB 및 자원이 반환된다.
이러한 프로세스의 흐름을 큐잉 다이어그램(Queuing Diagram) 으로 표현할 수 있으며, 시스템 내 프로세스의 이동을 시각적으로 이해하는 데 도움을 준다.
![[3.2.1.2.png]]

## 3.2.2 CPU 스케줄링
CPU 프케줄러의 역할
프로세스는 수명 주기 동안 준비 큐와 다양한 대기 큐를 이동한다. CPU 스케줄러는 준비 큐에서 프로세스를 선택하여  CPU 코어를 할당하는 역할을 한다.
- I/O 바운드 프로세스 -> - I/O 요청을 대기하기 전, 몇 밀리초 동안만 실행된다.
- CPU 바운드 프로세스 → 상대적으로 오랜 시간 CPU가 필요하지만, 스케줄러는 장기간 CPU를 할당하지 않고 **타임 슬라이스가 만료되면 강제로 제거**한다.

CPU 스케줄러는 일반적으로 매우 자주 실행되며, 최소 100밀리초마다 한 번씩 실행
- 목적: 다중 프로그래밍 정도를 조절하기 위해 일부 프로세스를 메모리에서 제거하여 가용                                                                                    
    1. 프로세스를 메모리에서 디스크로 스왑아웃(Swap Out) → 현재 상태 저장
    2. 필요 시 디스크에서 메모리로 스왑인(Swap In)  이전 상태 복원 후 실행 재개
- 사용 시점: 일반적으로 메모리 초과 사용 시 가용 공간 확보를 위해 필요

## 3.2.3 문맥 교환
문맥교환은 CPU 코어가 실행중인 프로세스를 중단하고 다른 프로세스를 실행하기 위해 상태를 저장하고 복구하는 과정이다.
문맥 교환 과정
1. 현재 실행중인 프로세스의 문맥을 저장 -> PCB에 저장
2. 새로은 프로세스의 문맥을 복구 -> PCB에서 값을 가져와  CPU 상태 복원
3. 새 프로세스를 실행
문맥에는 CPU 레지스터 값, 프로세스 상태, 메모리 관리정보 등이 포함된다.

문맥 교환 특징 
1. 인터럽트 발생 시 실행 : 인터럽트가 발생하면 커널은 현재 프로세스의 상태를 저장하고, 인터럽트 처리 후 복구한다.
2. CPU 스케줄링 시 필수적 : 한 프로세스에서 다른 프로세스로 전환될 때 반드시 수행된다.
3. 순수한 오버헤드 : 문맥 교환 동안 CPU는 실제 유용한 작업을 수행하지 않으므로 성능 저하 요소가 될 수 있다.

문맥 교환 속도에 영향을 주는 요소
1. 하드웨어 지원 여부: 일부 프로세서는 여러 개의 레지스터 집합을 제공하여 빠른 교환이 가능하다.
2. 메모리 복사량 : 활성 프로세스가 많을수록, 레지스터 및 메모리 정보를 저장하고 복구하는 시간이 증가한다.
3. 운영체제의 복잡성 : 고급 메모리 관리 기법을 사용할 경우, 문맥 교환 시 더 많은 데이터를 교환해야 하므로 시간이 더 걸린다.
4. 주소 공간 보존 필요성 : 문맥 교환 시 현재 프로세스의 주소 공간을 유지해야 하며, 이에 따라 추가적인 작업이 필요할 수 있다.
![[3.2.3.1.png]]

