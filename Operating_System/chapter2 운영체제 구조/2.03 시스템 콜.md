<font color="#0070c0">시스템 콜</font>은 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다. 특정 저수준 작업(예를 들면 하드웨어를 직접 접근해야 하는 작업)은 어셈블리 명령을사용하여 작성되어야 하더라도 이러한 호출은 일반적으로 C와 C + + 언어로 작성된 함 수 형태로 제공된다.

## 2.3.1 예제
![[운영체제3.png|800]]
시스템 콜이 어떻게 사용되는지를 설명하기 위해, 파일 복사 프로그램을 예로 들어보자. 첫 번째 단계는 입력 파일과 출력 파일의 이름을 얻는 것이다. 이는 명령어로 직접 전달하거나, 대화형 시스템에서 사용자에게 파일 이름을 입력받는 방식으로 이루어진다. 이 과정에서 여러 I/O 시스템 콜이 사용된다.

파일 이름이 얻어진 후, 프로그램은 입력 파일을 열고, 출력 파일을 생성한다. 각 파일을 여는 과정에서도 시스템 콜이 필요하며, 파일이 존재하지 않거나 접근이 금지된 경우 에러 메시지를 출력하고 종료한다. 출력 파일이 이미 존재하는 경우에는 기존 파일을 삭제하거나 덮어쓸지 여부를 사용자에게 물어보는 절차가 포함된다.

이후 파일을 복사하는 과정은 입력 파일에서 데이터를 읽고, 이를 출력 파일에 쓰는 루프를 반복하는 방식으로 이루어진다. 이 과정에서 발생할 수 있는 여러 오류 상황도 처리해야 한다.

마지막으로 파일을 닫고, 작업이 완료되었음을 알리는 메시지를 출력하며, 프로그램은 정상적으로 종료된다.

## 2.3.2 응용 프로그래밍 인터페이스

<font color="#0070c0">응용 프로그램 인터페이스</font>(Application Programming Interface, <font color="#0070c0">API</font>)는 응용 프로그램이 운영체제의 기능을 간편하게 사용할 수 있도록 하는 중간 계층이다. 개발자는 API를 통해 복잡한 시스템 콜을 직접 호출하지 않고도 운영체제의 기능을 사용할 수 있다. 예를 들어, Windows API나 UNIX/Linux의 POSIX API는 시스템 콜을 추상화하여 제공한다. 이러한 API는 주로 <font color="#0070c0">libc</font>와 같은 라이브러리에서 제공되며, 이는 C 언어를 기반으로 다양한 운영체제에서 공통적으로 사용된다.

### 실시간 환경(RTE)과 API의 역할

<font color="#0070c0">실시간 환경</font>(RTE)은 응용 프로그램이 시스템 콜을 호출할 수 있는 환경을 제공한다. 이 환경에서는 응용 프로그램이 특정 작업을 수행할 때 필요한 시스템 리소스와 기능을 관리한다. RTE는 <font color="#0070c0">시스템 콜 인터페이스</font>를 통해 운영체제와의 연결을 관리하며, 이 인터페이스는 API 호출을 통해 시스템 콜을 실행한다. RTE는 시스템 콜을 호출하는데 필요한 파라미터를 넘겨주고, 결과 값을 응용 프로그램으로 반환하는 역할을 한다.

### 스택을 통한 데이터 처리

시스템 콜 인터페이스에서 중요한 개념 중 하나는 <font color="#0070c0">스택</font>(stack)이다. API를 통해 시스템 콜을 호출할 때, 필요한 매개변수는 스택에 "<font color="#0070c0">넣어질</font>(push)" 수 있다. 스택은 호출된 함수나 시스템 콜에 매개변수를 전달하는 역할을 한다. 응용 프로그램이 시스템 콜을 호출하면, 매개변수는 스택에 저장되며, 이후 운영체제에 의해 "<font color="#0070c0">꺼내진다</font>(pop off)" 후 처리된다. 이러한 스택 구조는 매개변수의 순서를 보장하고, 함수 간의 데이터 전달을 효율적으로 처리할 수 있게 한다.
![[운영체제4.png|800]]

### 시스템 콜 인터페이스의 역할

시스템 콜 인터페이스는 API와 운영체제 사이의 중간 다리 역할을 한다. 응용 프로그램은 API를 호출하고, API는 시스템 콜 인터페이스를 통해 운영체제의 저 수준 기능을 접근한다. 이는 응용 프로그램이 직접적으로 운영체제의 세부 사항을 알 필요 없이 높은 수준의 추상화된 API로 작업할 수 있게 해준다. 시스템 콜 인터페이스는 운영체제가 API 요청을 어떻게 처리하고 실행하는지 담당하며, 이는 실시간 환경에서의 프로그램 동작을 보장하는 중요한 요소다.
![[운영체제5.png|800]]

## 2.3.3 시스템 콜의 유형

시스템 콜은 다섯 가지의 중요한 범주, 즉 <font color="#0070c0">프로세스 제어</font>, <font color="#0070c0">파일 조작</font>, <font color="#0070c0">장치 조작</font>, <font color="#0070c0">정보 유지 보수</font>와 <font color="#0070c0">통신과 보호</font> 등으로 묶을 수 있다. 이후 운영체제에 의해 제공되는 여러 가지 유형의 시스템 콜을 간단히 논의한다.

아래 내용은 운영체제에 의해 제공되는 통상적인 시스템 골의 유형을 요약하고 있다.

- 프로세스 제어(Process Control)
    - 끝내기 (end), 중지 (abort)
    - 적재(load), 수행(execute)
    - 프로세스 생성, 프로세스 종료
    - 프로세스 속성(attributes) 획득, 프로세스 속성(attributes) 설정
    - 시간을 기다림
    - 이벤트를 기다림 (wait event), 이벤트를 알림 (signal event)
    - 메모리 할당 및 자유화
- 파일 조작(File Manipulation)
    - 파일 생성 (create file), 파일 삭제(delete file)
    - 열기(open), 닫기(close)
    - 읽기/쓰기, 위치 변경(reposition)
    - 파일 속성 획득 및 설정
- 장치 관리 (Device Management)
    - 장치를 요구(request devices), 장치를 방출(release devices)
    - 읽기/ 쓰기, 위치 변경(reposition)
    - 장치 속성 획득, 장치 속성 설정
    - 장치의 논리적 부착(attach) 또는 분리 (detach)
- 정보 유지 (Information Maintenance)
    - 시간과 날짜의 설정과 획득
    - 시스템 데이터의 설정과 획득
    - 프로세스, 파일, 장치 속성의 획득
    - 프로세스, 파일, 장치 속성의 설정
- 통신 (Communication)
    - 통신 연결의 생성, 제거
    - 메시지의 송신, 수신
    - 상태 정보 전달
    - 원격 장치의 부착(attach) 및 분리 (detach)
- 보호 (Protection)
    - get file permissions
    - set file permissions

### 2.3.3.1 프로세스 제어

프로그램은 실행 중에 정상적으로 종료(예: `end()`)하거나 비정상적으로 중단(예: `abort()`)할 수 있다. 프로그램이 문제를 만나면 오류 트랩(trap)을 통해 오류가 기록되고, 디버거를 사용해 문제를 분석할 수 있다. 시스템 콜을 통해 명령 인터프리터는 다음에 실행할 명령을 받아들이며, 필요시 프로그램을 중단하거나 수정한다.

### 잠금과 공유 데이터 관리

공유되는 데이터의 일관성을 보장하기 위해, 운영체제는 프로세스가 공유 데이터를 잠글 수 있는 시스템 콜을 제공한다. 이러한 잠금(lock)메커니즘을 통해 여러 프로세스가 동시에 동일한 데이터를 변경하지 않도록 제어할 수 있으며, 이를 통해 데이터의 무결성을 유지한다. 예를 들어, 다중 프로세스 환경에서 데이터를 읽고 쓰는 동안 다른 프로세스가 동일한 데이터에 접근하지 못하도록 잠금을 설정할 수 있다. 이는 동기화 문제를 해결하는 데 중요한 역할을 한다.

### 스케치와 부트 로더(Arduino 예시)

Arduino와 같은 마이크로 컨트롤러에서는 프로그램 코드인 <font color="#0070c0">스케치</font>(sketch)를 사용하여 특정 작업을 수행한다. 스케치는 센서 데이터를 처리하거나 이벤트를 발생시키는 프로그램으로, Arduino 보드에 업로드된다. Arduino가 전원이 켜지면 <font color="#0070c0">부트 로더</font>(boot loader)가 실행되는데, 부트 로더는 새로운 스케치를 메모리에 적재하고 실행할 준비를 한다. 부트 로더는 하드웨어가 스케치를 실행할 수 있도록 환경을 설정하며, 새 스케치가 업로드될 때 기존 프로그램을 교체하는 역할을 한다.

- **Windows와 UNIX 시스템 콜 예**: 이 표는 두 운영체제가 제공하는 공통 시스템 콜 기능을 비교한다. 예를 들어, 프로세스 제어에서 Windows는 `CreateProcess()`, UNIX는 `fork()`를 사용한다.

![[2.3.3.1.png|400]]
![[2.3.3.2.png|400]]
### 2.3.3.2 파일 조작 (File Manipulation)

파일을 열고, 데이터를 읽고 쓰며, 파일을 닫는 등 파일과 관련된 작업은 다양한 시스템 콜을 통해 수행된다. 대표적으로 UNIX와 Linux에서는 `open()`, `read()`, `write()` 등의 함수가 이러한 작업을 처리한다. 파일 시스템 구조는 각 운영체제마다 다르지만, 대부분 파일과 장치에 대한 액세스 권한을 조절하기 위한 시스템 콜이 있다.

- **표준 C 라이브러리**: 이 라이브러리는 UNIX와 Linux에서 시스템 콜 인터페이스를 제공하며, `write()` 시스템 콜을 호출하여 응용 프로그램의 출력을 처리한다.

### 2.3.3.3 정보 유지 관리 (Information Maintenance)

운영체제는 시간, 날짜, 버전 정보, 메모리 사용량 등 시스템 정보를 유지 관리하는 다양한 시스템 콜을 제공한다. 이 시스템 콜은 사용자가 시스템 상태를 모니터링하거나 문제를 해결할 때 유용하다. 예를 들어, `time()` 시스템 콜을 사용하면 현재 시스템 시간을 얻을 수 있다. 또한, 메모리 덤프를 수행하거나 프로세스의 속성을 확인하기 위해 사용되기도 한다.
![[운영체제6.png|400]]

### 2.3.3.4 정보 유지 관리 (Information Maintenance)

운영체제는 시스템 시간, 날짜, 메모리 사용량과 같은 정보를 제공하는 시스템 콜을 통해 사용자와 프로그램 간의 정보 전달을 지원한다. 예를 들어, `time()`과 `date()` 시스템 콜은 현재 시간을 반환하며, 메모리 덤프를 수행하는 데 사용되는 `dump()` 시스템 콜도 존재한다. 또한, <font color="#0070c0">한 명령어 실행</font>**(single step)** 기능을 제공하는 CPU 모드는 명령어가 실행될 때마다 디버거를 통해 각 명령을 하나씩 실행하고 분석할 수 있도록 한다. 이러한 기능은 시스템 디버깅에 매우 유용하다.

### 2.3.3.5 통신 (Communication)

통신 모델에는 <font color="#0070c0">메시지 전달 모델</font>과 <font color="#0070c0">공유 메모리 모델</font>이 있다. 메시지 전달 모델에서는 두 프로세스가 서로 <font color="#0070c0">호스트 이름</font>과 <font color="#0070c0">프로세스 이름</font>을 기반으로 메시지를 주고받으며 통신한다. 프로세스 간 통신은 <font color="#0070c0">디먼</font>(daemon)이라는 백그라운드 프로세스를 통해 이루어지기도 하며, 이 디먼은 클라이언트-서버 모델에서 <font color="#0070c0">클라이언트</font>와 <font color="#0070c0">서버</font> 간의 메시지를 전달한다. 서버는 클라이언트의 요청을 받아들이고 응답을 제공하는 역할을 한다.

공유 메모리 모델에서는 여러 프로세스가 동일한 메모리 영역을 공유하여 데이터를 교환할 수 있다. 이 모델은 주로 성능이 중요한 경우 사용되며, 데이터를 읽고 쓰는 데 있어 동기화가 필요한 경우 운영체제는 잠금(lock) 기능을 제공하여 일관성을 유지한다.