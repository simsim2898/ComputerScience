## 2.7.1 설계 목표
- 시스템 목표와 명세 정의의 어려움
    
    - 시스템 설계는 하드웨어 및 시스템 유형(일괄처리, 시분할, 단일/다중 사용자, 분산, 실시간, 범용 등) 에 따라 달라짐.
    - 최상위 설계 수준을 넘어서면 **구체적인 요구 조건을 명확히 정의하기 어려움**.
- 요구 조건의 두 가지 주요 그룹
    - 사용자 요구: 사용하기 쉽고, 배우기 쉬우며, 안전하고 신속한 시스템을 기대함.
    - 시스템 요구: 설계, 구현, 유지보수가 쉬우며, 적응성, 신뢰성, 효율성을 갖춰야 함.
    - 하지만 이러한 요구 조건들은 애매하고 다양한 해석이 가능하여 설계에 직접적인 도움이 되지 않음.
- 운영체제 설계에서 다양한 해결 방법
    - 환경에 따라 요구 조건과 해결 방법이 다름.
    - 예: 실시간 운영체제**(Wind River VxWorks)와 대규모 서버 운영체제(Windows Server)의 요구 조건은 크게 다름.
- 운영체제 설계의 창조성
    - 운영체제의 명세와 설계는 정해진 해결책이 없는 창조적인 작업.
    - 소프트웨어 공학에서 개발된 일반적인 원칙이 운영체제 설계에도 적용될 수 있음.
## 2.7.2 기법과 정책
- 기법과 정책의 개념
    - 기법(Mechanism): "어떻게 할 것인가?"를 결정하는 기술적 방법.
    - 정책(Policy): "무엇을 할 것인가?"를 결정하는 운영 방침.
    - 예: **타이머 구조**는 CPU 보호를 위한 기법, 특정 사용자의 타이머 시간을 정하는 것은 정책.
- 기법과 정책의 분리 중요성
    - 정책은 환경과 시간에 따라 변경될 수 있음 → 기법과 정책을 분리하면 **융통성(flexibility)** 증가.
    - 기법이 정책에 종속되면, 정책 변경 시 기법도 수정해야 하는 문제 발생.
    - 따라서, 다양한 정책에서 사용될 수 있도록 유연한 기법을 설계하는 것이 바람직함.
    - 예: 우선순위 설정 기법이 정책과 분리되면, **CPU 중심 vs. I/O 중심 프로그램** 간 우선순위를 쉽게 변경 가능.
- 운영체제에서의 기법과 정책 적용 방식
    
    - 마이크로커널 기반 운영체제
        - **기법과 정책을 철저히 분리**하여 프리미티브 빌딩 블록을 제공.
        - 정책은 커널 모듈이나 사용자 프로그램을 통해 추가 가능.
    - Windows 및 macOS/iOS
        - **기법과 정책을 밀접하게 결합**하여 통일된 사용자 경험 제공.
        - 인터페이스가 커널 및 시스템 라이브러리에 내장됨.
    - Linux
        - **기본적인 CPU 스케줄링 알고리즘**(기법)이 제공되지만, **누구나 정책을 수정하거나 교체 가능**.
        - 공개 소스 운영체제의 특성을 반영한 유연한 구조.
- 자원 할당과 정책 결정
    - 모든 자원 할당 문제에는 정책 결정이 중요.
    - **"무엇을(What) 할 것인가?"** → 정책 결정.
    - **"어떻게(How) 할 것인가?"** → 기법 결정.

## 2.7.3 구현
- 운영체제 구현 개요
    - 운영체제는 **여러 프로그램의 집합체**로, 다양한 개발자가 오랜 시간에 걸쳐 구축.
    - 초기 운영체제는 **어셈블리 언어**로 작성되었지만, 현재는 **C 또는 C++ 같은 고급 언어**가 주로 사용됨.
    - **커널의 최하위 레벨**은 어셈블리어와 C로, **상위 루틴 및 시스템 라이브러리**는 C 또는 C++로 작성되는 경우가 많음.
    - **Android 운영체제 예시**:
        - 커널: C + 일부 어셈블리어
        - 시스템 라이브러리: C 또는 C++
        - 응용 프로그램 프레임워크: Java
- 운영체제를 고급 언어로 구현하는 장점
    - **빠른 코드 작성 및 유지보수 용이** → 코드가 간결하고 이해 및 디버깅이 쉬움.
    - **컴파일러 기술 발전** → 재컴파일만으로 코드 최적화 가능.
    - **이식성 향상** → 다양한 하드웨어(임베디드, x86, ARM 등)에서 쉽게 실행 가능.
- 고급 언어 사용의 단점과 극복
    - **속도 저하 & 저장 공간 문제** → 현대 시스템에서는 더 이상 주요 문제가 아님.
    - **최적화된 어셈블리 코드 vs. 컴파일러 최적화**
        - 숙련된 어셈블리어 프로그래머가 최적화된 코드를 작성할 수 있지만,
        - 현대 **컴파일러는 복잡한 분석과 최적화를 수행하여 고성능 코드 생성 가능**.
        - 최신 CPU는 **파이프라이닝과 병렬 연산을 통해 성능 최적화 가능**.
- 운영체제 성능 최적화의 핵심 요소
    - **알고리즘과 자료구조가 성능 향상의 핵심 요인** → 어셈블리어보다 중요한 역할을 함.
    - 운영체제에서 **고성능이 중요한 핵심 루틴**:
        - **인터럽트 핸들러, 입출력 관리자, 메모리 관리자, CPU 스케줄러**.
    - **병목지점을 식별한 후 최적화 수행** → 필요한 부분만 어셈블리어로 수정 가능.