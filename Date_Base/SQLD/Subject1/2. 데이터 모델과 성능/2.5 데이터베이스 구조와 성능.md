## 1. 슈퍼/서브타입 데이터 모델
- 논리적 데이터 모델에서 주로 이용 (분석단계에서 많이 쓰임)
- 물리적 데이터 모델로 설계 시 문제 발생 (적당한 노하우 X → 1:1 또는 All in one 타입이 되어버려 성능 저하)
- 슈퍼타입 : 공통부분을 슈퍼타입으로 모델링
- 서브타입 : 공통으로부터 상속받아 다른 엔터티와 차이가 있는 속성만 모델링
## 2. 데이터베이스 성능 저하 원인 3가지
1.  Union 연산에 의해 성능 저하
	- 트랜잭션 : 전체를 일괄처리, 테이블 : 개별로 유지
2. 조인에 의해 성능 저하
	- 트랜잭션 : 슈퍼+서브타입 공통 처리, 테이블 : 개별로 유지
3. 불필요하게 많은 데이터 집적
	- 트랜잭션 : 서브타입만 개별로 처리, 테이블 : 하나로 통합
## 3. 슈퍼/서브타입 데이터 모델 변환을 통한 성능 향상
- 변환기준 : 데이터 양, 트랜잭션 유형
- 데이터 소량 : 데이터 처리 유연성 고려하여 가급적 1:1 관계 유지
- 데이터 대량 : 3가지 변환 방법 (개별 테이블, 슈퍼+서브타입 테이블, 하나의 테이블)
	1. 1:1 타입 (One to one type) : 개별로 처리하는 트랜잭션에 대해 개별 테이블 구성하여 1:1 관계 가짐
	2.  슈퍼/서브 타입 (Plus type) : 슈퍼+서브 공통으로 처리하는 트랜잭션에 대해 슈퍼/서브 각각 테이블 구성
	3. All in One 타입 (Single type) : 전체를 하나로 묶어 트랜잭션이 발생, 단일 테이블 구성

| 구분 | One to one type | plus type | Single type |
|:----:|:----:|:----:|:----:|
| 특징 | 개별 테이블 유지 | 슈퍼+서브타입 테이블 | 하나의 통합 테이블 |
| 확장성 | 우수함 | 보통 | 나쁨 |
| 조인 필요 수 | 많음 | 보통 | 적음 |
| I/O 성능저하 | 양호 | 양호 | 나쁨 |
| 관리 용이성 | 나쁨 | 나쁨 | 중등 |
| 적합 트랜잭션 유형 | 개별 테이블로 접근이 많은 경우 | 슈퍼+서브 형식 데이터 처리가 많은 경우 | 전체에 대한 일괄 처리가 많은 경우 |

⇨ 쪼개질수록 확장성 상승/ Disk, I/O 성능 상승/ 조인 성능 감소/ 관리 용이성 감소


## 4. PK/FK 칼럼 순서 및 성능
- 일반적인 프로젝트에선 PK/FK 칼럼 순서의 중요성을 인지하지 못해 데이터 모델링 되어있는 상태로
DDL을 생성하여 성능이 저하되는 경우가 빈번
2. 인덱스 중요성 : 데이터 조작 시 가장 효과적으로 처리될 수 있는 접근 경로 제공
	- 인덱스의 특징 : 여러개의 속성이 하나의 인덱스로 구성되어 있을 때, 앞쪽에 위치한 속성의 값이 비교자로 있어야 인덱스가 좋은 효율을 나타낼 수 있다. 앞쪽에 위치한 속성값이 가급적 ‘=’ 아니면 최소한의 범위인 ‘BETWEEN'이 들어와야 됨
3.  PK/FK 설계 중요성 : 데이터 접근 시 접근경로 제공, 설계단계 마지막에 칼럼 순서 조정
4.  PK 순서의 중요성 : 물리적 모델링 단계에서 스스로 생성된 PK 외에 상속되는 PK 순서도 중요
5.  FK 순서의 중요성 : 조인을 할 수 있는 수단이 됨(=경로), 조회 조건 고려해서 반드시
인덱스 생성

## 5. PK 순서를 조정하지 않으면 성능 저하 되는 이유
- 조회 조건(WHERE)에 따라 인덱스를 처리하는 범위가 달라짐
- PK의 순서를 인덱스 특징에 맞게 생성하지 않고 자동으로 생성하면, 테이블에 접근하는 트랜잭션이 인덱스 범위를 넓게 하거나 풀 스캔(full scan)을 유발

## 6. 물리적 테이블에 FK 제약이 걸려있지 않은 경우 인덱스 미생성으로 생긴 성능 저하
- 물리적으로 두 테이블 사이 FK 참조 무결성 관계를 걸어 상속받은 FK에 인덱스 생성

## 7. 인덱스 엑세스 범위 좁히는 가장 좋은 방법
- PK가 여러 개일 때, Where절에 사용하는 조건용 칼럼들이 우선순위가 되어야 함
- ‘=’, EQUAL 조건, 동등 조건에 있는 칼럼이 제일 앞으로
- BETWEEN, IN 범위 조건에 있는 칼럼이 그 다음 순위
- 나머지 PK는 그 뒤에 아무렇게나