이진 검색 트리는 정렬된 숫자 목록을 신속하게 유지 관리할 수 잇는 데이터 구조 이다.
- 각 트리 노드에는 최대 2개의 자식이 있으므로 이진 트리라고 한다.
- 시간에 따라 숫자의 존재를 검색하는데 사용할 수 있으므로 검색 트리 라고 한다. '0(log(n))'

이진 검색 트리와 일반 이진 트리를 구분하는 속성은 다음과 같다.
1. 왼쪽 하위 트리의 모든 노드를 루트 노드보다 작다.
2. 오른쪽 하위 트리의 모든 노드는 루트 노드보다 크다.
3. 각 노드의 두 하위 트리도 모두 BST이다. 즉 위의 두 가지 속성을 가진다.

![[이진 검색 트리(BST).01.png]]
루트보다 하나 더 작은 값을 갖는 오른쪽 하위 틔를 갖는 트리는 유요한 이진 검색 트리가 아님을 보여주기 위해 표시 된다.

오른쪽의 이진 트리는 노드 "3"의 오른쪽 하위 트리에 이보다 작은 값이 포함되어 있으므로 이진 검색 트리가 아니다.
이진 검색 트리에서 수행할 수 있는 두 가지 기본 작업은 다음과 같다.

### 검색 작업
알고리즘은 각 왼쪽 하위 트리가 루트 아래의 값을 갖고, 각 오른쪽 하위 트리가 루트 위의 값을 갖는 **BST**의 속성에 따라 달라집니다.

값이 루트 아래에 있으면 해당 값이 올바른 하위 트리에 없다고 확실히 말할 수 있습니다.  
왼쪽 하위 트리에서만 검색하면 되며, 값이 루트 위에 있으면 값이 왼쪽 하위 트리에 없다고 확실히 말할 수 있습니다.  
올바른 하위 트리에서만 검색하면 됩니다.

#### 연산:

```cpp
if (root == NULL)
    return NULL;

if (number == root->data)
    return root->data;

if (number < root->data)
    return search(root->left);

return search(root->right);
```


다이어그램으로 시각화
![[이진 검색 트리(BST).02.png]]
값이 발견되면 아래 이미지와 같이 각 재귀 단계에서 전파되도록 값을 반환 한다.

return search(struct node*)를 네 번 호출 
새 노드나 NULL을 반환하면 search(root)가 최종 결과를 반환할 때까지 값이 계속해서 반환된다.
![[이진 검색 트리(BST).03.png]]


### 삽입 작업

올바른 위치에 값을 삽입하는 것은 왼쪽 하위 트리가 루트보다 작고, 오른쪽 하위 트리가 루트보다 크다는 규칙을 유지하려고 하기 때문에 검색과 유사합니다.
값에 따라 오른쪽 하위 트리 또는 왼쪽 하위 트리로 계속 이동하고, 왼쪽 또는 오른쪽 하위 트리가 **NULL**인 지점에 도달하면 거기에 새 노드를 배치합니다.

#### 연산:

```cpp
if (node == NULL)
    return createNode(data);

if (data < node->data)
    node->left = insert(node->left, data);
else if (data > node->data)
    node->right = insert(node->right, data);

return node;
```

알고리즘은 간단하지 않으며 기존 BST 에 숫자를 추가하는 방법을 시각화 예제로 사용

![[이진 검색 트리(BST).04.png]]
4<8이므로 9의 왼쪽 자식을 통과
![[이진 검색 트리(BST).05.png]]
4>3이므로 8의 오른쪽 자식을 통과
![[이진 검색 트리(BST).06.png]]
4<6이므로 6의 왼쪽 자식을 통과
![[이진 검색 트리(BST).07.png]]
6의 왼쪽 자식으로 4를 삽입

노드를 연결 했지만 여전히 트리의 나머지 부분에 손상을 주지 않고 함수를 종료해야 한다.
이것은 'return node:' 결국 유용한 곳입니다. 의 경우 NULL 새로 생성된 노드가 반환 되어 부모 노드에 연결되고, 그렇지 않으면 루트로 돌아올 때까지 올라가면서 동일한 노드가 변경 없이 반환
이렇게 한다면 트리 위로 다시 이동할 떄 다른 노드 연결이 변경 되지 않는다.
![[이진 검색 트리(BST).08.png]]

### 삭제 작업
이전 검색 트리에서 노드를 삭제하는 경우는 세가지 이다.

#### 사례 I
첫 번째 경우 삭제될 노드는 리프 노드이다. 이러한 경우에는 트리에서 해당 노드를 삭제하면 된다.

![[이진 검색 트리(BST).09.png]]
4개는 삭제 예정
![[이진 검색 트리(BST).10.png]]
노드 삭제

#### 사례 II
두 번째 경우에는 삭제할 노드에 자식 노드가 하나만 있을 때 

1. 해당 노드를 하위 노드로 바꾼다.
2. 원래 위체에서 하위 노드를 제거 한다.

![[이진 검색 트리(BST).11.png]]
6 삭제 예정
![[이진 검색 트리(BST).12.png]]
자식 값을 노드에 복사하고 자식을 삭제 한다.
![[이진 검색 트리(BST).13.png]]
최종 트리

#### 사례 III
세 번째 경우에는 삭제할 노드에 두 개의 자식이 있을 때 

1. 해당 노드의 중위 계승자를 가져온다.
2. 노드를 중위 후속 노드로 교쳬 한다.
3. 중위 후속자를 원래 위치에서 제거 한다.

![[이진 검색 트리(BST).14.png]]
3개는 삭제 에정
![[이진 검색 트리(BST).15.png]]
중위 후속자(4)의 값을 노드에 복사 한다.
![[이진 검색 트리(BST).16.png]]
중위 계승자 삭제