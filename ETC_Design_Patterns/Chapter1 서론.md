# 1 서론
설계자로 하여금 재사용이 가능한 설계를 선택하고, 재사용을 방해하는 설계는 배제하도록 도와줌
또한 이미 만든 시스템의 시스템의 유지보수나 문서화도 개선할 수 있음

## 1.1 디자인 패턴이란?
디자인 패턴은 기존 환경내에서 반복적으로 일어나는 문제들을 설명한 후, 그 문제들에 대한 해법의 핵심을 설명함
객체 지향 설계
소프트웨어 개발에서 해법은 벽이나 문들 대신 객체와 인터페이스를 사용 하지만, 둘 모드 패턴을"어떤 상황의 문제에 대한 해법"으로 본다는 공통점이 있음
일반적으로 하나의 패턴에 필수적으로 존재하는 4가지 요소
1. 패턴 이름(Pattern name)
	1. 특정한 설꼐 문제와 해결을 한 단어로 표현한 것
	2. 설계 해법을 명확히 정의하고 쉽게 이해할 수 있도록 함
	3. 패턴의 이름은 설계 의도를 전달하고자 개발자 간의 의사소통을 원활하게 해줌
	4. 패턴을 분류하고 카탈로그를 만들 때 중요한 요소 중 하나
2. 문제(problem)
	1. 패턴이 해결하려는 설계 문제와 관련 된 상황을 설명
	2. 어떤 알고리즘을 객체로 만들 것인가? 와 같은 구체적인 설계 질문을 포함
	3. 패턴을 적용할 수 잇는 상황을 정의하고, 문제의 제약 조건을 설명함
	4. 특정한 설계 구조를 문제 상황에서 어떻게 활용할 것인지를 다룸
3. 해법(solution)
	1. 설계를 구성하는 요소들과의 그 관계를 서술
	2. 구체적인 구현 방법이 아니라 문제를 해결할 수 있는 일반적인 틀(템플릿)을 제공
	3. 패턴을 적용하여 클래스나 객체들이 협력하는 방식에 대한 설명 포함
4. 결과(consequence)
	1. 패턴을 적용한 후 얻을 수 있는 결과와 장단점을 분석
	2. 설계를 결정할 떄 결과를 고려하는 과정에서 비용과 효율을 측정하는 것이 중요함
	3. 소프트웨어 설계에서 시간과 공간의 균형을 맞추는 것이 필요
	4. 패턴이 시스템의 유연성, 확장성, 이식성 등에 미치는 영향을 설명

연결 리스트와 해시 테이블 등을 클래스로 표현하고 그것 자체로 다시 쓸 수 있도록 설계하는 문제를 어떻게 푸느냐에 관한 것이 아니고 응용 프로그램 전체나 서브시스템을 지원하는 복잡한 설계에 대한 것은 더더욱 아님
특정한 전후 관계에서 일반적 설계 문제를 해결하기 위해 상호 교류하는 수정 가능한 객체 클래스들에 대한 설명

## 1.2  스몰토크 MVC를 사용한 디자인 패턴

## 디자인 패턴 카탈로그 
**추상 팩토리(Abstract Factory)**
구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 패턴입니다.

**적응자(Adapter)**
클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해 줍니다.

**가교(Bridge)**
구현부에서 추상층을 분리하여 각각 독립적으로 변형할 수 있게 하는 패턴입니다.

**빌더(Builder)**
복잡한 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴입니다.

**책임 연쇄(Chain of Responsibility)**
요청을 처리할 수 있는 기회를 하나 이상 여러 객체에게 부여하여 요청을 보내는 객체와 요청을 받는 객체 사이의 결합을 피하는 패턴입니다.  
요청을 받을 수 있는 객체를 연결식으로 묶고, 실제 요청을 처리할 객체를 만날 때까지 객체 고리를 따라서 요청을 전달합니다.

**명령(Command)**
요청을 객체의 형태로 캡슐화하여, 서로 요청이 다른 사용자의 매개변수화, 요청 지정 또는 로깅, 그리고 연산의 취소를 지원하게 만드는 패턴입니다.

**복합체(Composite)**
객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 합니다.

**장식자(Decorator)**
주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 기능 확장이 필요할 때 서브클래스 대신 쓸 수 있는 유연한 대안이 될 수 있습니다.

**퍼사드(Facade)**
서비스시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공하는 패턴으로, 서비스시스템을 좀더 사용하기 편하게 만드는 상위 수준의 인터페이스를 정의합니다.

**팩토리 메서드(Factory Method)**
객체를 생성하는 인터페이스는 미리 정의하되, 인스턴스를 만들 클래스의 결정은 서브클래스 쪽에서 내리는 패턴입니다.  
팩토리 메서드 패턴에서는 클래스의 인스턴스를 만드는 시점을 서브클래스로 미룹니다.

**플라이급(Flyweight)**
크기가 작은 객체가 여러 개 있을 때, 공유를 통해 이들을 효율적으로 지원하는 패턴입니다.

**해석자(Interpreter)**
주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의하고, 이와 아울러 그 표현 수단을 사용하여 해당 언어로 작성된 문장을 해석하는 해석기를 정의하는 패턴입니다.

**반복자(Iterator)**
내부 표현을 노출하지 않고 어떤 객체 집합에 속한 원소들에 순차적으로 접근할 수 있는 방법을 제공하는 패턴입니다.

 **중재자(Mediator)**
한 객체에 속해 있는 객체들의 상호작용을 캡슐화하는 객체를 정의하는 패턴입니다.  
객체들이 직접 서로를 참조하지 않도록 함으로써, 객체들 사이의 소결합(loose coupling)을 촉진시키며, 개발자가 객체들의 상호작용을 독립적으로 다양화시킬 수 있게 만듭니다.

**메멘토(Memento)**
캡슐화를 위배하지 않은 채 어떤 객체의 내부 상태를 잡아내고 실제화시켜, 이후에 해당 객체가 그 상태로 다시 되돌아올 수 있도록 하는 패턴입니다.

**감시자(Observer)**
객체 사이에 일대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만드는 패턴입니다.

**원형(Prototype)**
생성할 객체의 종류를 명시화하는 데 원형이 되는 예시물을 이용하고, 그 원형을 복사함으로써 새로운 객체를 생성하는 패턴입니다.

**프록시(Proxy)**
어떤 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자(surrogate) 또는 자리채움자(placeholder)를 제공하는 패턴입니다.

**단일체(Singleton)**
어떤 클래스의 인스턴스는 오직 하나임을 보장하며, 이 인스턴스에 접근할 수 있는 전역적인 접촉점을 제공하는 패턴입니다.

**상태(State)**
객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가하는 패턴으로, 이렇게 하면 객체는 마치 자신의 클래스를 바꾸는 것처럼 보입니다.

**전략(Strategy)**
동일 계열의 알고리즘을 정의하고, 각각의 알고리즘을 캡슐화하며, 이들을 상호교환이 가능하도록 만드는 패턴입니다.  
알고리즘을 사용하는 사용자와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 합니다.

**템플릿 메서드(Template Method)**
객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로 미루는 패턴입니다.  
알고리즘의 구조 자체는 그대로 둔 채 알고리즘 각 단계의 처리를 서브클래스에서 재정의할 수 있게 합니다.

**방문자(Visitor)**
객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴으로, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있게 합니다.